(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{439:function(t,a,r){"use strict";r.r(a);var e=r(42),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"function-arguments"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#function-arguments"}},[t._v("#")]),t._v(" Function.arguments")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("function.arguments属性代表传入函数的实参，它是一个类数组对象。")])]),t._v(" "),r("h3",{attrs:{id:"描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),r("p",[t._v("function.arguments已经被废弃了，现在推荐的做法是使用函数内部可用的arguments对象来访问函数的实参。")]),t._v(" "),r("p",[t._v("在函数递归调用的时候(在某一刻同意函数运行了多次，也就是有多套实参)，那么arguments属性值是最近一次该函数调用时传入的实参。")]),t._v(" "),r("p",[t._v("如果函数不再执行期间，那么该函数的arguments属性的值是null")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function f(n) {g(n - 1);}\n\nfunciton g(n) {\n    console.log('before: ' + g.arguments[0]);\n    if (n > 0) { f(n); }\n    console.log('after ' + g.arguments[0]);\n}\n\nconsole.log(`函数退出后的arguments属性值：${g.arguments}`);\n// 输出\n// brefore: 1\n// brefore: 0\n// after: 0\n// after: 1\n// 函数退出后的arguments属性值：null\n")])])]),r("h2",{attrs:{id:"arguments对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arguments对象"}},[t._v("#")]),t._v(" Arguments对象")]),t._v(" "),r("p",[t._v("arguments是一个对应于传递给函数的参数的类数组对象")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function func1(a, b, c) {\n    console.log(arguments[0]);\n    // expected ouput: 1\n\n    console.log(arguments[1]);\n    // expected output: 2\n\n    console.log(arguments[3]);\n    // expected output: 3\n}\nfunc1(1, 2, 3);\n")])])]),r("h3",{attrs:{id:"描述-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#描述-2"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),r("p",[t._v("arguments对象是所有(非箭头)函数中都可用的局部变量。你可以用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每一个参数，第一个参数在索引0处。例如，如果一个函数传递了三个参数，你可以以如下方式引用他们：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("arguments[0];\narguments[1];\narguments[2];\n")])])]),r("p",[t._v("参数也可以被设置")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("arguments[1] = 'new value'\n")])])]),r("p",[t._v("arguments对象不是一个Array。它类似于Array，但除了length属性和索引属性之后没有任何Array属性。例如，它没有pop方法。但是它可以被转换成一个真正的Array")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("var args = Array.prototype.slice.call(arguments);\nvar args = [].slcie.call(arguments);\n\n// ES2015\nconst args = Array.from(arguments);\nconst args = [...arguments];\n")])])]),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),r("p",[t._v("对参数使用slice会阻止某些JavaScript引擎中的优化(比如V8-"),r("a",{attrs:{href:"https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments",target:"_blank",rel:"noopener noreferrer"}},[t._v("更多信息"),r("OutboundLink")],1),t._v(")。如果你关心性能，尝试通过遍历arguments对象来构造一个新的数组。另一种方法是使用被忽视的Array构造函数作为一个函数")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("var  args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));\n")])])])]),t._v(" "),r("p",[t._v("如果调用的参数多余正式声明的参数，则可以使用arguments对象。这种技术对于可以传递可变变量的参数的函数很有用。使用arguments.length来确定传递给函数参数的个数，然后使用arguments对象处理每个参数。要确定函数签名中(输入)参数的数量，请使用Function.length属性")]),t._v(" "),r("h4",{attrs:{id:"对参数使用typeof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对参数使用typeof"}},[t._v("#")]),t._v(" 对参数使用typeof")]),t._v(" "),r("p",[t._v("typeof参数返回'object'")]),t._v(" "),r("h4",{attrs:{id:"对参数使用扩展语法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对参数使用扩展语法"}},[t._v("#")]),t._v(" 对参数使用扩展语法")]),t._v(" "),r("h4",{attrs:{id:"属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[t._v("#")]),t._v(" 属性")]),t._v(" "),r("ol",[r("li",[t._v("arguments.callee\n"),r("ul",[r("li",[t._v("指向参数所属的当前执行的函数")]),t._v(" "),r("li",[t._v("指向调用当前函数的函数")])])]),t._v(" "),r("li",[t._v("arguments.length\n"),r("ul",[r("li",[t._v("传递给函数的参数变量")])])]),t._v(" "),r("li",[t._v("arguments[@@interator]\n"),r("ul",[r("li",[t._v("返回一个新的Array迭代器对象，该对象包含参数中每个索引的值")])])])]),t._v(" "),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments",target:"_blank",rel:"noopener noreferrer"}},[t._v("原文地址"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"剩余参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#剩余参数"}},[t._v("#")]),t._v(" 剩余参数")]),t._v(" "),r("p",[t._v("剩余参数语法允许我们将一个不定数量的参数表示为一个数组。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function sum(...theArgs) {\n    return theArgs.reduce((previous, currents) => {\n        return previout + current;\n    })\n}\n\nconsole.log(sum(1, 2, 3));\n// expected output: 6\n\nconsole.log(sum(1,2,3,4));\nexpected output: 10\n")])])]),r("h3",{attrs:{id:"语法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function (a, b, ...theArgs) {\n    // ....\n}\n")])])]),r("h3",{attrs:{id:"描述-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#描述-3"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),r("p",[t._v("如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组，其中从0(包括)到theArgs.length(排除)的元素由传递给函数的实际参数提供。")]),t._v(" "),r("p",[t._v("在上面例子，theArgs将收集该函数的第三个参数(因为第一个参数被映射到a,而第二个参数映射到b)和所有后续参数")]),t._v(" "),r("h3",{attrs:{id:"剩余参数和arguments对象的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#剩余参数和arguments对象的区别"}},[t._v("#")]),t._v(" 剩余参数和arguments对象的区别")]),t._v(" "),r("p",[t._v("剩余参数和arguments对象之间的区别主要有三个")]),t._v(" "),r("ul",[r("li",[t._v("剩余参数只包含那些没有对应形参的是实参，而arguments对象包含了传递给函数的所有实参。")]),t._v(" "),r("li",[t._v("arguments对象不是一个真正的数组，而剩余参数是真正是的Array示例，也就是说你能够在它上面直接使用所有的数组方法，比如sort，map， forEach或pop")]),t._v(" "),r("li",[t._v("arguments对象还有一个附件的属性(入callee属性)")])]),t._v(" "),r("h3",{attrs:{id:"从arguments到数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从arguments到数组"}},[t._v("#")]),t._v(" 从arguments到数组")]),t._v(" "),r("p",[t._v("引入了剩余参数来减少由参数引起的样板代码")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function f(a, b) {\n    var normalArray = Array.prototype.slice.call(arguments)// or\n    var normalArray = [].slice.call(arguments);\n    // or\n    var normalArray = Array.for(arguments);\n\n    var first = normalArray.shift(); // ok\n    var first = arguments.shift(); // Error\n}\n\nfunction f(...args) {\n    var normalArray = args;\n    var fist = normalArray.shift(); // ok\n}\n")])])]),r("h3",{attrs:{id:"结构剩余参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构剩余参数"}},[t._v("#")]),t._v(" 结构剩余参数")]),t._v(" "),r("p",[t._v("剩余参数可以被结构，这意味着他们的数据可以被姐报道不同的变量中,"),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",target:"_blank",rel:"noopener noreferrer"}},[t._v("结构赋值"),r("OutboundLink")],1)]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function f(...[a, b, c]) {\n    return a + b + c;\n}\nf(1); // NAN\nf(1, 2, 3); // 6\nf(1,2,3,4); // 6\n")])])]),r("h3",{attrs:{id:"示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),r("p",[t._v("因为theArg是个数组，所以你可以使用length属性得到剩余参数的个数")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function fun1(...theArgs) {\n    alert(theArgs.length)\n}\nfunc1(); // 弹出0\nfun1(5); // 弹出1\nfun1(5, 6, 7); // 弹出3\n")])])]),r("p",[t._v("下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以他们:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function multiply(mutiplier, ...theArgs) {\n    return theArgs.map(function (element) {\n        return mutiplier * element;\n    })\n}\nvar arr = multiply(2, 1, 2, ,3);\nconsole.log(arr); // [2,4,6]\n")])])]),r("p",[t._v("下面例子演示了你可以在剩余参数上使用任意的数组防范，而arguments对象不可以")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function sortRestArgs(...theArgs) {\n    var sortedArgs = theArgs.sort();\n    return sortedArgs;\n}\n\nalert(sortRestArgs(5, 3,7, 1));\n\nfunction sortArguments() {\n    var sortedArgs = arguments.sort();\n    return sortedArgs; // 不会执行到这里\n}\nalert(sortArguments(5, 3, 7, 1)); // 抛出TypeError异常：arguments.sort is not a function\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);