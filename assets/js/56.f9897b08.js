(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{431:function(e,a,t){"use strict";t.r(a);var n=t(42),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"遍历器-迭代器-iterator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历器-迭代器-iterator"}},[e._v("#")]),e._v(" 遍历器(迭代器)Iterator")]),e._v(" "),t("h3",{attrs:{id:"for遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for遍历"}},[e._v("#")]),e._v(" for遍历")]),e._v(" "),t("p",[e._v("首先从远古讲起，刚出js的时候如何遍历一个数组呢")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr = [1, 2, 3, 4, 7, 8, 9]\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n")])])]),t("h3",{attrs:{id:"foreach遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreach遍历"}},[e._v("#")]),e._v(" forEach遍历")]),e._v(" "),t("p",[e._v("看起来笨的一批，所以ES5给你研究了一个foreach方法，但是这个方法不能break，也不能改变数组自身的值，也不能返回任何值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr = [1, 2, 3, 4, 7, 8, 9];\nvar arr2 = arr.forEach((element, index) => {\n    console.log(`第${index}个数值为${element}`);\n    return element * 2;\n})\nconsole.log(arr2); // undefined\nconsole.log(arr1); // [1, 2,3,4, 8 , 9]\n")])])]),t("p",[e._v("所以说foreach只给你最基本的操作，其他一概不管，如果你想要改变自身的值或者有break和countinue操作我们可以使用map操作，不展开说了。"),t("a",{attrs:{href:"https://www.cnblogs.com/wangzirui98/p/11226781.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("数组遍历方法总结"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"for-in遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-in遍历"}},[e._v("#")]),e._v(" for-in遍历")]),e._v(" "),t("p",[e._v("那么ES6专门为遍历数组提供了一种方法，就是for-of。说到for-of，不得不提到for-in")]),e._v(" "),t("p",[e._v("那么关于他们两的区别，"),t("a",{attrs:{href:"https://www.cnblogs.com/wangzirui98/p/11227853.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入理解枚举属性与for-in和for-of"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("值得一提的是for-in是可以遍历数组的，但是不推荐用for-in遍历数组，为什么呢？因为for-in返回的可枚举属性是字符类型，不是数字类型，如果'0', '1'这样的属性和1，2数组发生相加，很可能不是直接相加，二十字符串的叠加。例如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const items = [1,2, 3,4];\nfor (item in items) {\n    let tempitem = item + 1;\n    console.log(items[tempitem]); // undefined\n    console.log(tempitem); // 01 21, 31 41 item与数字相加，会得到字符串相加的结果\n}\n")])])]),t("p",[e._v("所以为了便面歧义，还是不要用for-in遍历数组比较好")]),e._v(" "),t("h3",{attrs:{id:"for-of"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-of"}},[e._v("#")]),e._v(" for-of")]),e._v(" "),t("p",[e._v("接下来进入正题了，因为for-in在数组这边比较难用，所以ES6新添加的for-of来弥补for-in的不足。这个是正儿八经遍历数组的方法。与forEach()不同的是，它支持break、continue和return语句.而且他本身的语法非常简单")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (variable of iterable) {\n    // statements\n}\n")])])]),t("ul",[t("li",[e._v("variable: 在每次迭代中，将不同属性的值分配给变量")]),e._v(" "),t("li",[e._v("iterable: 被迭代枚举启属性的对象。")])]),e._v(" "),t("p",[e._v("而且关键的问题是for-of不仅可以遍历数组，他也可以遍历很多类似数组对象。")]),e._v(" "),t("ul",[t("li",[e._v("Array")]),e._v(" "),t("li",[e._v("Map")]),e._v(" "),t("li",[e._v("Set")]),e._v(" "),t("li",[e._v("String")]),e._v(" "),t("li",[e._v("TypedArray")]),e._v(" "),t("li",[e._v("函数的arguments对象")]),e._v(" "),t("li",[e._v("NodeList对象")])]),e._v(" "),t("p",[e._v("而他的原理在于这些类数组对象中都有一个属性，就是Symbol.iterator,也就是说，只要带Symbol.iterator他都能遍历，我们单独把这个属性拿出来，自己手动执行next()方法就会看到我们成功遍历了这个数组")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const items = [1,2, 3,4];\nconst giao = items[Symbol.iterator]();\nconsole.log(giao.next()); // {value: 1, done: false};\nconsole.log(giao.next()); // {value: 2, done: false};\nconsole.log(giao.next()); // {value: 3, done: false};\nconsole.log(giao.next()); // {value: 4, done: false};\nconsole.log(giao.next()); // {value: undefined, done: true};\n")])])]),t("p",[e._v("同理，我们可以通过手动写一个iterator来更深入的了解他的原理：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Array.prototype.myiterator = function() {\n    let i = 0;\n    let items = this;\n    return {\n        next() {\n            const done = i >= item.length;\n            const value = done ? undefined : items[i++]\n            return {\n                value, \n                done\n            }\n        }\n    }\n}\nconst item = [1,2,3,4];\n \n// 控制台\nconst giao = item.myiterator(); // 当我们获得遍历器时，我们只需要代替for-of执行myiterator即可遍历这个数组\ngiao.next(); // {value: 1, done: false}\ngiao.next(); // {value: 2, done: false}\ngiao.next(); // {value: 3, done: false}\ngiao.next(); // {value: 4, done: false}\ngiao.next(); // {value: undefined, done: true}\n")])])]),t("p",[e._v("效果更for of 一样。另外值得注意的是，你可以在任意对象里添加这个属性，让他们可遍历。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const items = ['blue', 'yellow', 'white', 'black'];\nfor(item of items) {\n    console.log(item);\n}\n")])])]),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("遍历器如果存在一个对象内,它就可以让这个对象可供for-of遍历，for-of的遍历方法就是不停的调用遍历器的next()方法，知道done属性编委true。")]),e._v(" "),t("h2",{attrs:{id:"生成器generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成器generator"}},[e._v("#")]),e._v(" 生成器Generator")]),e._v(" "),t("p",[e._v("本质上，"),t("strong",[e._v("生成器函数返回的就是一个遍历器")])]),e._v(" "),t("p",[e._v("生成器的语法很简单，就是在function后面加个*,然后用yield来返回对应的值。(其实也可以将yield看做return,只不过需要next()来进行外调用，还有一个函数只能由一个return，而yield可以有多个)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* items() {\n    yield '1';\n    yield '2';\n    yield '3'\n}\nconst num = items();\n\n// 控制台\nnum.next(); // {value: '1', done: false}\nnum.next(); // {value: '2', done: false}\nnum.next(); // {value: '3', done: false}\nnum.next(); // {value: undefined, done: true}\nnum.next(); // {value: undefined, done: true}\n")])])]),t("p",[e._v("那么我们yield的之间同样也可以加入运算")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function* items() {\n    let i = 0;\n    yield i; // 0\n    i++;\n    yield i // 1\n    i++\n    yield i // 2\n    i++ // 这个就不运行了，因为他在yield之后\n}\nconst num = items();\n// 不用浏览器控制台，直接打印也行\nconsole.log(nu.next()); // {value: 0, done: false}\nconsole.log(nu.next()); // {value: 1, done: false}\nconsole.log(nu.next()); // {value: 2, done: false}\nconsole.log(nu.next()); // {value: undefined, done: true}\n")])])]),t("p",[e._v("利用这样的特性，我们可以用Generator来进行ajax的等待操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fuction ajax(url) {\n    // 请求成功自动调用next()方法。然后返回数据结果\n    axios.get(url).then(res => gen.next(res.data));\n}\nfunction* step() {\n    const class = yield ajax.get('http://laotie.com/getclass');\n    const score = yield ajax.get(`http://laotie.com/getscore?name=￥{class[0].name}`)\n}\n// 获得这个函数的遍历器\nconst gen = step();\n// 启动'遍历器',不启动就不会东\ngen.next(); // 获取class\ngen.next(); // 获取到score\n")])])]),t("p",[e._v("因为第二个get请求依赖第一个请求的结果，所以我们解决办法第一个运用Promise的回调来限制他们的先后顺序。但是在我们学习了生成器之后发现生成器很适合做这样的事，也就是只有当第一个请求执行完之后，才能顺序执行第二个请求。")]),e._v(" "),t("p",[e._v("另外还有一些小的特性")]),e._v(" "),t("p",[e._v("*可以添加到任意位置，都不会影响genterator。下面的下发都是可以的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function * foo(x, y) {...}\nfunction *foo(x, y) {...}\nfunction* foo(x, y) {...}\nfunction*foo(x, y) {...}\n")])])]),t("p",[e._v("关于Generator的Thunk或者co模块，因为ES8的async的加入，极大简化了Generator的操作")]),e._v(" "),t("h2",{attrs:{id:"async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[e._v("#")]),e._v(" async")]),e._v(" "),t("h3",{attrs:{id:"语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),t("p",[e._v("准确的说,async就是Generator的语法糖，首先看他的语法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function laotie() {\n    const data = await dosomething();\n}\n")])])]),t("p",[e._v("可以看到，")]),e._v(" "),t("ul",[t("li",[e._v("原来的*由async代替")]),e._v(" "),t("li",[e._v("原来的yield由await代替\n这样做的直接好处就是更加语义化，可读性更强。但是其实async做到的远不止如此。")])]),e._v(" "),t("ol",[t("li",[e._v("首先第一点，就是async不用不断执行next()了，async函数内置了执行器，使的我们在调用函数时，只需要直接调用就可以")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 接上一个代码块\nlaotie()\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("现在async的await还是保留这等待的功能,但是因为没有了next(),所以在调用await不会像yield那样返回值了。在async中，只有return返回，而且返回的是一个promise对象.")])]),e._v(" "),t("p",[e._v("拿上面的代码直接改成async加await格式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function items() {\n    let i = 0; \n    await i;\n    i++;\n    await i;\n    i++;\n    await i;\n    i++\n}\nconsole.log(items()) // Promise{<pending>}\n")])])]),t("p",[e._v("直接调用方法我们能看到返回的是一个状态为resolved的Promise对象，而不是Iterator.")]),e._v(" "),t("p",[e._v("而这个对象，返回的值就是函数里return出来的值。我们可以用then()函数来接受这个值并答应它。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function items() {\n    let i = 3;\n    return i ;\n}\nitems().then(res => {\n    console.log(res); // 3\n})\n")])])]),t("p",[e._v("当然这么举例子准定不是正经的用法，这些例子主要用于区分Generator和async函数之间的区别。")]),e._v(" "),t("h3",{attrs:{id:"用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[e._v("#")]),e._v(" 用法")]),e._v(" "),t("p",[e._v("正确的用法现在是在await之后加入一个异步函数, await相当于将这个异步函数转化为同步函数，等这个异步函数执行完毕返回resolved的时候才往下执行进一步的操作：例如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function asyncPrint(value, ms) {\n    await new Promise(resolve => {\n        setTimeout(resoove, ms);\n    })\n    console.log(value);\n}\nasyncPrint('hello world', 1000); // 疫苗打印除hello world\n")])])]),t("p",[e._v("如果这个async的函数中间有多个await，那么就让多个await以排队的方式执行。")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("用法2")])])]),e._v(" "),t("p",[e._v("先让我们把之前generator的例子拿过来")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function ajax(url) {\n    // 请求成功自动调用next()方法。然后返回数据结果\n    axios.get(url).then(res => gen.next(res.data))\n}\nfunction* step() {\n    const class = yield ajax.get('http://laotie.com/getClass');\n    const score = yield ajax.get(`http://laotie.com/getscore?name=${class[0].name}`);\n}\n\n// 获得这个函数的遍历器\nconst gen = step();\n// 启动遍历器\ngen.next();\n")])])]),t("p",[e._v("写着挺累的，但是async可以快速的简化它。因为await接受的就是一个Promise函数，所以我们可以直接在await后面使用axios，然后直接使用对象解构赋值获取相应的值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async function step() {\n    const {data: {class}} = await axios.get(`http: //laotiecom/getclass`);\n    cosnt {data: {core}} = await axios.get(`http://laotie.com/getscore?name=${class[0].name}`);\n    return {class, sore}\n}\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);