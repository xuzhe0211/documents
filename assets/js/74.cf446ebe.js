(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{452:function(n,t,a){"use strict";a.r(t);var e=a(42),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"概括"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概括"}},[n._v("#")]),n._v(" 概括")]),n._v(" "),a("ol",[a("li",[n._v("bind() 返回一个新函数，并不会理解执行")]),n._v(" "),a("li",[n._v("bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参钱传入作为他的参数")]),n._v(" "),a("li",[n._v("bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然有效")])]),n._v(" "),a("h2",{attrs:{id:"代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Function.prototype.bind = function(obj, arg) {\n    var arg = Array.prototype.slice.call(arguments, 1);\n    var context = this;\n    var bound = function(newArg) {\n        arg = arg.concat(Array.prototype.slice.call(newArg));\n        return context.apply(obj, arg);\n    }\n    var F = function() {}; // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此...\n    F.prototype = context.prototype;\n    bound.prototype = new F();\n    return bound;\n}\n")])])]),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/goloving/p/9380076.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("参考文档"),a("OutboundLink")],1)]),n._v(" "),a("h2",{attrs:{id:"bind使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind使用"}},[n._v("#")]),n._v(" bind使用")]),n._v(" "),a("h3",{attrs:{id:"bind和curring-函数柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind和curring-函数柯里化"}},[n._v("#")]),n._v(" bind和curring，函数柯里化")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function add(a, b, c) {\n    var i = a + b + c;\n    console.log(i);\n    return i;\n}\nvar func = add.bind(undefined, 100); // 给add()传了第一个参数a\nfunc(1, 2); // 103，继续传入b和c\n\nvar func2 = func.bind(undefined, 200); // 给func2传入第一个参数，也就是b，此前func已有参数a =100\nfunc2(10); // 310,继续传入c, 100+200+10\n")])])]),a("p",[n._v("可以利用此种特性方便代码重用，如下，可以不同的页面只需要配置某几项，前面几项固定的配置可以选择用bind函数先绑定好，将一个复杂的函数拆分成简单的子函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function getConfig(colors, size, otherOptions) {\n    console.log(colors, size, otherOptions);\n}\nvar defaultConfig = getConfig.bind(null, '#cc0000', '1024*768');\ndefaultConfig('123')\ndefaultConfig('456')\n")])])]),a("h3",{attrs:{id:"bind和new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind和new"}},[n._v("#")]),n._v(" bind和new")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo() {\n    this.b = 100;\n    console.log(this.a);\n    return this.a;\n}\n\nconst func = foo.bind({a: 1});\nfunc(); // 1\nnew func(); //undefined {b: 100},可以看到此时上面的bind并不起作用\n")])])]),a("p",[n._v("函数中的return除非返回的是个对象，否则通过new返回的是个this，指向一个空对象，空对象原型指向foo.prototype, 空对象的b属性是100.也就是说通过new的方式创建一个对象，bind()函数在this层面并不起作用，但是需要注意在参数层面上扔起作用。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo(c) {\n    this.b = 100;\n    console.log(this.a);\n    console.log(c);\n    return this.a;\n}\n\nconst funnc = foo.bind({a: 1}, 20);\nnew func(); // undefined 20,通过new创建对象func,bind绑定的c依旧起作用\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);