(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{400:function(n,a,t){"use strict";t.r(a);var e=t(42),r=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("TIP")]),n._v(" "),t("p",[n._v("将原本需要通过传入回调参数来实现回调执行（或者叫同步执行）改为利用promise的.then的方式来调用,从而实现逻辑上的同步操作。")])]),n._v(" "),t("h2",{attrs:{id:"异步函数promise化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步函数promise化"}},[n._v("#")]),n._v(" 异步函数promise化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 第一种\nmodule.exports = function promisify(fn) {\n    return function (...args) {\n        return new Promise(function (resolve,reject) {\n            args.push(function (err,...arg) {\n                if(err){\n                    reject(err)\n                }else{\n                    resolve(...arg);\n                }\n            });\n            fn.apply(null, args);\n        })\n    }\n}\n// 第二种\nmodule.exports = function promisify(fn) {\n    return function(...args) {\n        return new Promise((resolve, reject) => {\n            let callback = function(...args) {\n                resolve(args);\n            }\n            fn.apply(null, [...args, callback]);\n        })\n    }\n}\n")])])]),t("h2",{attrs:{id:"实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[n._v("#")]),n._v(" 实例")]),n._v(" "),t("h3",{attrs:{id:"例子1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子1"}},[n._v("#")]),n._v(" 例子1")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// foo 可以是任何需要调用回调函数的函数\nfunction foo(str1, str2, callback) {\n    setTimeout(() => {\n        console.log('setTimeout');\n        // callback函数是通过最后一个参数这个位置来识别的，与callback名字无关\n        callback(str1, str2)\n    }, 1000);\n}\n\n// 这里的agent已经不是foo函数，而是我们在promisify中返回的自定义匿名函数\n// 所以不需要纠结是否传入callback函数。\nlet agent = promisify(foo);\n\nagent('hello', 'world').then(res => {\n    console.log(res);\n})\n")])])]),t("p",[n._v("输出结果：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("setTimeout\n[ 'hello', 'world' ]\n")])])]),t("h3",{attrs:{id:"例子2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子2"}},[n._v("#")]),n._v(" 例子2")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fun(arg, callback) {\n    try {\n        // aaa()\n        callback(null, 'result')\n    } catch (error) {\n        callback(error)\n    }\n    console.log('fs ' + arg)\n}\n\nconst promise = promisify(fun)\n\n// await方式\nsetTimeout(async () => {\n    try {\n        await promise('./aaa.txt', (err, data) => {\n            console.log(err ? 'read err' : `${data}1`);\n        })\n    } catch (error) {\n        console.log('catch err', error)\n    }\n})\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);