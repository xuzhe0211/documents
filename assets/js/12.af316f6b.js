(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{366:function(e,r,t){e.exports=t.p+"assets/img/6201114.54d8ed17.png"},448:function(e,r,t){"use strict";t.r(r);var s=t(42),v=Object(s.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"service-worker是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#service-worker是什么"}},[e._v("#")]),e._v(" Service Worker是什么")]),e._v(" "),s("h3",{attrs:{id:"一句话概括"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一句话概括"}},[e._v("#")]),e._v(" 一句话概括")]),e._v(" "),s("p",[e._v("一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker那么它可以拦截当前网站所有的请求，进行判断(需要编写响应的判断程序)，如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存不再转给服务器。从而大大提高浏览体验。")]),e._v(" "),s("h3",{attrs:{id:"一下是一些细碎的描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一下是一些细碎的描述"}},[e._v("#")]),e._v(" 一下是一些细碎的描述")]),e._v(" "),s("ul",[s("li",[e._v("基于web worker(一个独立于JavaScript主线程的独立线程，在里面执行需要消耗大量资源的操作不会堵塞主线程)")]),e._v(" "),s("li",[e._v("在web worker的基础上增加了离线缓存的能力")]),e._v(" "),s("li",[e._v("本质上充当Web应用程序(服务器)与浏览器之间的代理服务器(可以拦截全站的请求，并做出相应的动作->由开发者指定的动作)")]),e._v(" "),s("li",[e._v("创建有效的离线体验(将一些不常更新的内容缓存在浏览器，提高访问体验)")]),e._v(" "),s("li",[e._v("由事件驱动的，具有生命周期")]),e._v(" "),s("li",[e._v("可以访问cache和indexDB")]),e._v(" "),s("li",[e._v("支持推送")]),e._v(" "),s("li",[e._v("并且可以让开发者自己控制缓存的内容以及版本")])]),e._v(" "),s("h2",{attrs:{id:"service-worker的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#service-worker的生命周期"}},[e._v("#")]),e._v(" Service Worker的生命周期")]),e._v(" "),s("p",[e._v("service worker有完全独立于web页面的生命周期。")]),e._v(" "),s("p",[e._v("如果你要给你的网站使用servide worker，你需要在指定的页面的JavaScript中注册。注册service worker后，浏览器会默默地在背后安装service worker。")]),e._v(" "),s("p",[e._v("在安装这一步中，你可能需要缓存一些静态资源。如果所有这些文件缓存成功，则service worker安装成功；相反，如果有文件下载缓存失败，则安装步骤失败，此时service worker不会被激活(没装上)。但是别担心，稍后还是会继续安装的")]),e._v(" "),s("p",[e._v("安装成功后，会启动激活步骤，此时非常适合用来处理旧缓存")]),e._v(" "),s("p",[e._v("激活成功后，service worker会控制其范围内的所有页面。第一次注册service worker的页面，会等到页面加载成功后，才会接受控制。一旦service worker在控制页面，它只会有两种状态：要么停止运行，要么处理页面中的fetch和message事件(当叶茂中有网络请求或消息时)")]),e._v(" "),s("p",[e._v("下面这种图显示了service worker第一次安装时的生命周期：")]),e._v(" "),s("p",[s("img",{attrs:{src:t(366),alt:"service worker声明周期"}})]),e._v(" "),s("h2",{attrs:{id:"如何使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何使用"}},[e._v("#")]),e._v(" 如何使用")]),e._v(" "),s("ol",[s("li",[e._v("注册Service Worker在你的index.html加入一下内容")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 判断当前浏览器是否支持serviceWorker\nif ('serviceWorker' in navigator) {\n    // 当页面加载完成就创建一个serviceWorker\n    window.addEventListener('load', function() {\n        // 创建并指定对应的执行内容\n        // scope参数是可选的，可以用来指定你想让service worker控制的内容的子目录。在这个例子里，我们指定了'/'，表示根网络下的所有内容。这也是默认值\n        navigator.serviceWorker.register('./serviceWorker.js', {scope: './'}).then(function(registration) {\n            console.log('ServideWorker registration successful with scope: ', registration.scope);\n        }).catch(function(err) {\n            console.log('ServiceWorker registration failed:', err);\n        })\n    })\n}\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[e._v("安装woker: 在我们指定的处理程序serviceWorker.js中书写对应的安装及拦截逻辑")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 监听安装事件，install事件一般是被用来设置你的浏览器的离线缓存逻辑\nthis.addEventListener('install', function(event) {\n    // 通过这个方法可以防止缓存未完成，就关闭serviceWorker\n    event.waitUntil(\n        // 创建一个名叫v1的缓存版本\n        caches.open('v1').then(function(cache) {\n            // 指定要缓存的内容，地址为相对于根域名的访问路径\n            return cache.addAll([\n                './index.html'\n            ])\n        })\n    )\n})\n\n// 注册fetch事件，拦截全站请求\nthis.addEventListener('fetch', function(event) {\n    event.respondWith(\n        // magic goes here\n        // 在缓存中匹配对应请求资源直接返回\n        caches.match(event.request);\n    )\n})\n")])])]),s("blockquote",[s("p",[e._v("以上为一个最简单的使用例子，更多内部api请查看"),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API",target:"_blank",rel:"noopener noreferrer"}},[e._v("mdn service worker"),s("OutboundLink")],1)])]),e._v(" "),s("h2",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[e._v("#")]),e._v(" 注意事项")]),e._v(" "),s("p",[e._v("Service worker运行在worker上下文--\x3e不能访问DOM")]),e._v(" "),s("p",[e._v("它设计为完全异步，同步API(如XHR和localStorage) 不能在service worker中使用")]),e._v(" "),s("p",[e._v("出于安全考量，Service Worker只能由HTTPS承载")]),e._v(" "),s("p",[e._v("在Firefox浏览器的用户隐私模式，Service Worker不可用")]),e._v(" "),s("p",[e._v("其生命周期与页面无关(关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动)")]),e._v(" "),s("h2",{attrs:{id:"有趣的事"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有趣的事"}},[e._v("#")]),e._v(" 有趣的事")]),e._v(" "),s("p",[e._v("在MDN的兼容情况中可以看到Safari 对于Service workers的全线不支持，这是因为通过Service workers可以在浏览器上实现一种类似小程序的功能（PWA）。这将绕过苹果的app store导致苹果不能再和开发者37开分成，所以苹果不喜欢这项技术。ps:不过还是在18年开始支持了")])])}),[],!1,null,null,null);r.default=v.exports}}]);