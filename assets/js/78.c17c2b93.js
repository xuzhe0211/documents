(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{458:function(e,t,r){"use strict";r.r(t);var a=r(42),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),r("p",[e._v("装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。")]),e._v(" "),r("p",[e._v("这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。")]),e._v(" "),r("p",[e._v("我们通过下面的实例来演示装饰器模式的用法。其中，我们将吧一个形状装饰上不通的颜色，同时有不改变形状类。")])]),e._v(" "),r("h2",{attrs:{id:"定义一个方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义一个方法"}},[e._v("#")]),e._v(" 定义一个方法")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("class log{\n    print(msg) {\n        console.log(msg);\n    }\n}\nconst log = new Log();\nlog.print('hello');\n")])])]),r("h2",{attrs:{id:"装饰一下print函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#装饰一下print函数"}},[e._v("#")]),e._v(" 装饰一下Print函数")]),e._v(" "),r("ul",[r("li",[e._v("日志美化")]),e._v(" "),r("li",[e._v("执行日志AOP")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const dec = (target, property) => {\n    const old = target.prototype.print;\n    target.prototype[property] = msg => {\n        console.log('执行pront方法....')；\n        msg = `{${msg}}`;\n        old(msg);\n    }\n}\ndec(Log, 'print');\n")])])]),r("h2",{attrs:{id:"装饰器工厂"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#装饰器工厂"}},[e._v("#")]),e._v(" 装饰器工厂")]),e._v(" "),r("ul",[r("li",[e._v("打印定制化")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const dec = name => (target,proptery) => {\n    const old = target.prototype.print;\n    target.prototype[property] = msg => {\n        console.log('执行pront方法....')；\n        msg = `{${msg}}`;\n        old(msg);\n    }\n}\ndec('name')(Log, 'print');\n")])])]),r("h2",{attrs:{id:"注解风格的装饰器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注解风格的装饰器"}},[e._v("#")]),e._v(" 注解风格的装饰器")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function decorate(target, property, descriptor) {\n    var oldValue = descriptor.value;\n    descriptor.value = msg => {\n        msg = `[${msg}]`;\n        return oldValue.apply(null, [msg]);\n    }\n    return descriptor;\n}\n\nclass Log{\n    @decorate\n    print(msg) {\n        console.log(msg);\n    }\n}\n")])])]),r("ol",[r("li",[e._v("anotation 源码")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const anotation = (target,proterty,decorate) => {\n    const descriptor = decorate(Log.prototype, proterty, Object.getOwnPropertyDescriptor(Log.prototype, proterty))\n    Object.defineProperty(Log.prototype, proterty, descriptor)\n}\nanotation(Log,'print',decorate)\n")])])]),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/6844904164045094926",target:"_blank",rel:"noopener noreferrer"}},[e._v("原文地址"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("p",[e._v("[地址] (https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)")]),e._v(" "),r("h3",{attrs:{id:"object-getownpropertydescriptor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-getownpropertydescriptor"}},[e._v("#")]),e._v(" Object.getOwnPropertyDescriptor()")]),e._v(" "),r("p",[e._v("object.getOwnPropertyDescriptor()方法返回指定对象上一个自有属性对应的属性描述符(自有属性指的是直接赋予改对象的属性，不需要从原型链上进行查找的属性)。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("cosnt object1 = {\n    property1: 42\n}\nconst descriptor1 = Object.getOwnPropertyDescriptor(object1, 'property1');\n\nconsole.log(descriptor1.configurable); // true;\n\nconsole.log(descriptor1.value); // 42\n\n")])])]),r("h4",{attrs:{id:"描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[e._v("#")]),e._v(" 描述")]),e._v(" "),r("p",[e._v("该方法允许对一个属性的描述进行检索。")]),e._v(" "),r("h3",{attrs:{id:"object-defineproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" Object.defineProperty")]),e._v(" "),r("p",[e._v("Object.defineProperty()方法直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此属性。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const object1 = {};\n\nObject.defineProperty(object1, 'property1', {\n  value: 42,\n  writable: false\n});\n\nobject1.property1 = 77;\n// throws an error in strict mode\n\nconsole.log(object1.property1);\n")])])]),r("h4",{attrs:{id:"语法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("obj")]),e._v(" "),r("p",[e._v("要定义属性的对象")])]),e._v(" "),r("li",[r("p",[e._v("prop")]),e._v(" "),r("p",[e._v("要定义或修改的属性的名称或Symbol")])]),e._v(" "),r("li",[r("p",[e._v("descriptor")]),e._v(" "),r("p",[e._v("要定义或修改的属性描述符")])])]),e._v(" "),r("h4",{attrs:{id:"描述-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#描述-2"}},[e._v("#")]),e._v(" 描述")]),e._v(" "),r("p",[e._v("该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for...in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。")]),e._v(" "),r("p",[e._v("对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。")]),e._v(" "),r("p",[e._v("这两种描述符都是对象。它们共享以下可选键值（默认值是指在使用 Object.defineProperty() 定义属性时的默认值）：")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("configurable")]),e._v(" "),r("p",[e._v("当且仅当该属性的configurable键值为true时,该属性的描述符才能被改变，同时该属性也能从对应的对象上被删除")]),e._v(" "),r("p",[e._v("默认为false")])]),e._v(" "),r("li",[r("p",[e._v("enumberable")]),e._v(" "),r("p",[e._v("当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。")]),e._v(" "),r("p",[e._v("默认为 false。")])])]),e._v(" "),r("h4",{attrs:{id:"数据描述符还具有以下可选键值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据描述符还具有以下可选键值"}},[e._v("#")]),e._v(" 数据描述符还具有以下可选键值：")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("value")]),e._v(" "),r("p",[e._v("该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。")]),e._v(" "),r("p",[e._v("默认为 undefined。")])]),e._v(" "),r("li",[r("p",[e._v("writable")]),e._v(" "),r("p",[e._v("当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。")]),e._v(" "),r("p",[e._v("默认为 false。")])])]),e._v(" "),r("h4",{attrs:{id:"存取描述符还具有以下可选键值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存取描述符还具有以下可选键值"}},[e._v("#")]),e._v(" 存取描述符还具有以下可选键值：")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("get")]),e._v(" "),r("p",[e._v("属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。")]),e._v(" "),r("p",[e._v("默认为 undefined。")])]),e._v(" "),r("li",[r("p",[e._v("set\n属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。")]),e._v(" "),r("p",[e._v("默认为 undefined。")])])]),e._v(" "),r("h3",{attrs:{id:"示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例")]),e._v(" "),r("ol",[r("li",[e._v("数据属性")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var person = {}\nObject.defineProperty(person,'name',{\n    configurable:false,// 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为false\n    enumerable:false,// 对象属性是否可通过for-in循环，flase为不可循环，默认值为false\n    writable:false,// 对象属性是否可修改,flase为不可修改，默认值为false\n    value:'xiaoming' //对象属性的默认值，默认值为undefined\n});\n\n//value\nconsole.log(person);//xiaoming，默认value\n\n//writable\nperson.name=\"qiang\";\nconsole.log(person);//xiaoming，不可修改value\n\n//enumerable\nfor(var i in person){\n    console.log(person[i]) //无结果，不可循环\n}\n\n//configurable\ndelete person.name\nconsole.log(person.name)//xiaoming，不可删除\n\nObject.defineProperty(person,'name',{\n    configurable:true //不可修改，将抛出错误\n});\n\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[e._v("访问器属性")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var book = {\n    _year: 2004,//属性前面加_，代表属性只能通过对象方法访问\n    edition: 0\n}\nObject.defineProperty(book,'year',{\n    get: function(){\n        return this._year;\n    },\n    set: function(newValue){\n        if(newValue > 2004){\n            this._year = newValue;\n            this.edition += newValue - 2004\n        }\n    }\n});\nconsole.log(book.year)//2004\nbook.year = 2006;\nconsole.log(book.year)//2006\nconsole.log(book.edition)//2\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);