(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{386:function(e,t,a){"use strict";a.r(t);var r=a(42),l=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"reflect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflect"}},[e._v("#")]),e._v(" Reflect")]),e._v(" "),a("h3",{attrs:{id:"reflect概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflect概述"}},[e._v("#")]),e._v(" Reflect概述")]),e._v(" "),a("p",[e._v("Reflect对象与proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象设计目的有一下几个")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("将Object对象的一些明显属于语言层面的方法放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。")])]),e._v(" "),a("li",[a("p",[e._v("修改某些Object方法的返回结果，让其变得更合理。比如Object.defineProperty(obj, name, desc)在无法定义属性时会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false")])]),e._v(" "),a("li",[a("p",[e._v("让Object操作都变成函数行为。某些Object操作试试命令式，比如 name in obj 和delete obj[name],而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让他们编程函数行为")])]),e._v(" "),a("li",[a("p",[e._v("Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便的调用对应的Reflect方法完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总在Reflect上获取默认行为。")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Proxy(target, {\n\tset: function(target, name, value, receiver) {\n    \tvar success = Reflect.set(target, name, value, receiver);\n        if (success) {\n        \tlog(`property ${name} on ${target} set to ${value}`);\n        }\n        return success;\n    }\n})\n")])])]),a("p",[e._v("上面的代码中，Proxy方法拦截了target对象属性赋值的行为。它采用Reflect.set方法赋值给对象的属性，然后在部署额外功能")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var loggedObj = new Proxy(obj, {\n\tget(targe, name) {\n    \tconsole.log('get', target, name);\n\t\treturn Reflect.get(target, name);\n    },\n    deleteProperty(target, name) {\n    \tconsole.log('delete' + name);\n\t\treturn Reflect.deleteProperty(target, name);\n    },\n    has(target, name){\n    \tconsole.log('has '+ name);\n        return Reflect.has(target, name);\n    }\n})\n")])])]),a("p",[e._v("上面代码中，每一个Proxy对象的拦截操作(get, delete, has)内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作就是将一个操作输出一行日志")]),e._v(" "),a("h3",{attrs:{id:"reflect方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflect方法"}},[e._v("#")]),e._v(" Reflect方法")]),e._v(" "),a("p",[e._v("Reflect对象方法如下。")]),e._v(" "),a("ol",[a("li",[e._v("Reflect.getOwnPropertyDescriptor(target, name);")]),e._v(" "),a("li",[e._v("Reflect.defineProperty(target, name, desc);")]),e._v(" "),a("li",[e._v("Reflect.getOwnPropertyNames(target);")]),e._v(" "),a("li",[e._v("Reflect.getPropertyOf(target);")]),e._v(" "),a("li",[e._v("Reflect.setPropertyOf(target, prototype);")]),e._v(" "),a("li",[e._v("Reflect.deleteProperty(target, name);")]),e._v(" "),a("li",[e._v("Reflect.enumerate(target)")]),e._v(" "),a("li",[e._v("Reflect.freeze(target)")]),e._v(" "),a("li",[e._v("Reflect.seal(target)")]),e._v(" "),a("li",[e._v("Reflect.preventExtensionos(target);")]),e._v(" "),a("li",[e._v("Reflect.isFrozen(target);")]),e._v(" "),a("li",[e._v("Reflect.isSealed(target);")]),e._v(" "),a("li",[e._v("Reflect.has(target, name);")]),e._v(" "),a("li",[e._v("Reflect.hasOwn(target, name);")]),e._v(" "),a("li",[e._v("Reflect.keys(target);")]),e._v(" "),a("li",[e._v("Reflect.get(target, name, receiver);")]),e._v(" "),a("li",[e._v("Reflect.set(target, name, value, receiver);")]),e._v(" "),a("li",[e._v("Reflect.apply(target, thisArg, args);")]),e._v(" "),a("li",[e._v("Reflect.construct(target, args)")])]),e._v(" "),a("p",[e._v("上面这些方法的作用，大部分与Object对象的同名方法是相同的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Reflect.get(target, name, receiver);\n//查找并返回target对象的name属性，如果没有改属性，则返回undefined.\n//如果name属性部署了读取函数，则读取函数的this绑定receiver.\nvar obj = {\n\tget foo() { return thiss.bar(); },\n    bar:function() {...}\n}\n//下面的语句会让this.bar()编程调用wrapper.bar();\nReflect.get(obj, 'foo', wrapper);\n\n\n\nReflect.set(target, name, value, receiver);\n//设置target对象的name属性等于value.如果哦name属性设置了赋值函数，则复制函数的this绑定receiver.\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//Reflect.set方法设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。\nvar myObject = {\n  foo: 4,\n  set bar(value) {\n    return this.foo = value;\n  },\n};\n\nvar myReceiverObject = {\n  foo: 0,\n};\n\nReflect.set(myObject, 'bar', 1, myReceiverObject);\nmyObject.foo // 4\nmyReceiverObject.foo // 1\n")])])]),a("h2",{attrs:{id:"js数组扁平化-flat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js数组扁平化-flat"}},[e._v("#")]),e._v(" JS数组扁平化(flat)")]),e._v(" "),a("p",[a("strong",[e._v("需求：")]),e._v(" 多维数组=> 一维数组")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let ary = [1, [2, [3, [4,5]]], 6];\nlet str = JSON.stringify(arr);\n")])])]),a("p",[e._v("** 第0种处理：直接调用**")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("arr_flat = arr.flat(Infinity);\n")])])]),a("p",[e._v("** 第一种处理 **")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ary = str.replace(/(\\[|\\])/g, '').split(',')\n")])])]),a("p",[e._v("** 递归调用 **")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let result = [];\nlet fn = function(ary) {\n\tfor (let i = 0; i < ary.length; i++) {\n    \tlet item = ary[i];\n        if (Array.isArray(ary[i])) {\n        \tfn(item);\n        } else {\n        \tresult.push(item);\n        }\n    }\n}\n")])])]),a("p",[e._v("** 用reduce实现数组的flat方法 **")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function flatten(ary) {\n\treturn ary.reduce((pre, cur) => {\n    \treturn pre.concat(Array.isArray(cur) ? flatten(cur) : cur);\n    })\n}\n")])])]),a("p",[e._v("** 扩展运算符 **")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("while(ary.some(Array.isArray)) {\n\tary = [].concat(...ary);\n}\n")])])]),a("p",[e._v("数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组拉平，变成一维数组。该方法返回一个新数组，对原数据没有影响。")]),e._v(" "),a("p",[e._v("如果原数组有空位，flat()方法会跳过空位。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[1,2,,4,5].flat();\n//[1,2,4,5]\n")])])]),a("p",[e._v("flatMap()方法对原数组的每个成员执行一个函数，相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//相当于[[2,4], [3,6],[4,8]].flat();\n[2,3,4].flatMap(x => [x, x*2])\n//[2,4,3,6,4,8]\n")])])])])}),[],!1,null,null,null);t.default=l.exports}}]);