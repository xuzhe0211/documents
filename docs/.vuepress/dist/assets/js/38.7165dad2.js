(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{398:function(t,s,e){"use strict";e.r(s);var r=e(42),n=Object(r.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"super用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super用法"}},[t._v("#")]),t._v(" super用法")]),t._v(" "),e("p",[t._v("super关键字，即可以当做函数使用，也可以当做对象使用。在这两种情况下，它的作用完全不同。")]),t._v(" "),e("ul",[e("li",[t._v("第一种情况，super作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行super函数。子类没有写constructor方法，js引擎默认，帮你执行constructor（） {super()}")]),t._v(" "),e("li",[t._v("第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类")])]),t._v(" "),e("p",[e("strong",[t._v("由于spuer指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的")])]),t._v(" "),e("h2",{attrs:{id:"super是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super是什么"}},[t._v("#")]),t._v(" super是什么")]),t._v(" "),e("h3",{attrs:{id:"super类似于es5语法中的call继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super类似于es5语法中的call继承"}},[t._v("#")]),t._v(" super类似于ES5语法中的call继承")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A {\n\tconstructor(n) {\n    \tconsole.log(n); // => 100\n        this.x = 100;\n    }\n    getX() {\n    \tconsole.log(this.x);\n    }\n}\nclass B extends A { // => extends类似实现原型继承\n\tconstructor() {\n    \tsuper(100); // => 类似call的继承，在这里super相当于把A的constructor给执行了，并且让方法中的this是B的实例，super当中传递的实参都是在给A的constructor传递。\n\t\tthis.y = 200;\n    }\n    getY() {\n    \tconsole.log(this.y);\n    }\n}\nlet f = new B();\n\n")])])]),e("h3",{attrs:{id:"super用法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super用法-2"}},[t._v("#")]),t._v(" super用法")]),t._v(" "),e("p",[t._v("既然super是一个可以调用的东西，它是一个函数嘛？？")]),t._v(" "),e("p",[t._v("这个问题的答案很容易找到，可以把super赋值给其他变量试试，会得到一个语法错误")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A extends Object {\n  constructor() {\n    const a = super;  //=>Uncaught SyntaxError: 'super' keyword unexpected here\n    a(); \n  }\n};\n")])])]),e("p",[t._v("因为 super 的词法定义是伴随后面那对括号的，它和 this 不同。this 的定义是 this 这个关键字会被替换成一个引用，而 super 则是 super(…) 被替换成一个调用。而且 super 除了在 constructor 里直接调用外还可以使用 super.xxx(…) 来调用父类上的某个原型方法，这同样是一种限定语法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" class A {\n      constructor(name,color) {\n      this.name = name;\n      this.color = color;\n    }\n    // toString 是原型对象上的属性\n    toString() {\n      console.log('name:' + this.name + ',color:' + this.color);\n\n    }\n  }\n\n class B extends A{\n  constructor() {\n    super('cat','white');\n  }\n  toString() {\n    console.log(super.toString());\n  }\n }\n\n var cat = new B()\n cat.toString();  //=>name:cat,color:white\n")])])]),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/2a5a7352f4e5",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考地址"),e("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=n.exports}}]);