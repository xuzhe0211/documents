(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{368:function(t,n,a){"use strict";a.r(n);var r=a(42),s=Object(r.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"二叉树格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树格式"}},[t._v("#")]),t._v(" 二叉树格式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var root = {\n\tval:5,\n    left:{\n    \tval:4,\n        left:{\n        \tval: 3\n        },\n        right:{\n        \tval:2\n        }\n    },\n    right:{\n   \t\tval: 6,\n        left:{\n        \tval:7\n        },\n        right:{\n        \tval: 8\n        }\n    }\n}\n")])])]),a("h2",{attrs:{id:"二叉树的遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历"}},[t._v("#")]),t._v(" 二叉树的遍历")]),t._v(" "),a("h3",{attrs:{id:"前序遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前序遍历"}},[t._v("#")]),t._v(" 前序遍历")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function rootTraverse(root) {\n\tlet res = [];\n    dfs(root);\n\treturn res; \n}\nfunction dfs(root){\n    if (root) {\n        res.push(root.val);\n        root.left && dfs(root.left);\n        root.right && dfs(root.right);\n    }\n}\n")])])]),a("p",[t._v("非递归")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function rootRraverse(root) {\n\tvar result = [];\n    var strack = [root];\n    while(strack.length) {\n    \tlet node = strack.pop();\n        result.push(node.val);\n        node.right && strack.push(node.right);\n        node.left && strack.push(node.left);\n    }\n    return result;\n}\n")])])]),a("h3",{attrs:{id:"中序遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中序遍历"}},[t._v("#")]),t._v(" 中序遍历")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function rootTraverse(root) {\n\tlet res = [];\n    dfs(root);\n\treturn res; \n}\nfunction dfs(root){\n\tif (root) {\n    \troot.left && dfs(root.left);\n        res.push(root.val);\n        root.right && dfs(root.right);\n    }\n}\n")])])]),a("h3",{attrs:{id:"后序遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后序遍历"}},[t._v("#")]),t._v(" 后序遍历")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function rootTraverse(root) {\n\tlet res = [];\n    dfs(root);\n\treturn res; \n}\nfunction dfs(root){\n\tif (root) {\n    \troot.left && dfs(root.left);\n        root.right && dfs(root.right);\n        res.push(root.val);\n    }\n}\n")])])]),a("h3",{attrs:{id:"广度遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#广度遍历"}},[t._v("#")]),t._v(" 广度遍历")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function dfsRraverse(root) {\n\tvar res = [];\n    var strack = [root];\n    var count = 0;\n    function dfs(root) {\n        var node = strack[count];\n        if(node) {\n            res.push(node.val);\n            node.left && strack.push(node.left);\n            node.right && strack.push(node.right);\n            count++\n            dfs();\n        }\n    }\n    dfs();\n    return res;\n}\n")])])]),a("h3",{attrs:{id:"右明树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#右明树"}},[t._v("#")]),t._v(" 右明树")]),t._v(" "),a("ol",[a("li",[t._v("递归")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function rightSideView(root) {\n\tif (!root) return [];\n    var arr = [];\n    dfs(root, 0, arr);\n    return arr\n}\nfunction dfs(root, step, res) {\n\tif (root) {\n    \tif(res.length === step) {\n    \t\tres.push(root.val)\n    \t}\n    }\n    root.right && dfs(root.right, step+1, res);\n    root.left && dfs(root.left, step+1, res);\n}\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("非递归")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function rightSideView(root) {\n\tif (!root) return [];\n    let equeue = [root];\n    let arr = [];\n    while(equeue.length > 0){\n    \tlet len = equeue.length;\n        while(len) {\n        \tlet node = equeue.shift();\n            if(len == 1) arr.push(node.val);\n            node.left && equeue.push(node.left);\n            node.right && equeue.push(node.right);\n            len--;\n        }\n    }\n    return arr;\n}\n")])])]),a("h2",{attrs:{id:"二叉树中和为某一值的路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树中和为某一值的路径"}},[t._v("#")]),t._v(" 二叉树中和为某一值的路径")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function PathSum (root, sum) {\n\tlet res = [];\n    let path = [];\n    dfsHelper(root, path, sum, res);\n    return res;\n}\nfunction dfsHelper(root, path, expectedNum, res) {\n\tif (!root) return;\n    if(!root.left && !root.right) {\n    \tif(expectedNum === root.val) {\n        \tres.push([...path, root.val]);\n            return;\n        }\n    }\n   \tpath.push(root.val);\n    dfsHelper(root.left, path, expectedNum - root.val, res);\n    dfsHelper(root.right, path, expectedNum - root.val, res);\n    path.pop(root.val);\n}\n")])])]),a("h2",{attrs:{id:"二叉树最近的公共祖先"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树最近的公共祖先"}},[t._v("#")]),t._v(" 二叉树最近的公共祖先")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("root = [3,5,1,6,2,0,8,null, null,7,4];\np = 5, q = 1;\nfunction LowestCommonAncestor(root, p, q) {\n\tif (!root || root.val === p || root.val === q) return root;\n    const left = LowestCommonAncestor(root.left, p,q);\n    const right = LowestCommonAncestor(root.right, p, q);\n    if(!left) return right;\n    if(!right) return left;\n    return root;\n}\n")])])]),a("h2",{attrs:{id:"路径总和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路径总和"}},[t._v("#")]),t._v(" 路径总和")]),t._v(" "),a("p",[t._v("给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有的节点值等于目标和")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var hasPathSum = function(root, sum) {\n\t//如果不存在，表示不是叶子节点\n    if(!root) return false;\n    //如果是叶子节点，判断减去这个节点是否为o\n    if(!root.left && !root.right) return sum - root.val === 0;\n    //左右节点递归寻找一条存在的pathSum\n    return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);\n}\n")])])]),a("h2",{attrs:{id:"将有序数组转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将有序数组转换"}},[t._v("#")]),t._v(" 将有序数组转换")]),t._v(" "),a("p",[t._v("将一个按照升序排列的有序数组，转换成一颗高度平衡的二叉树。"),a("br"),t._v("\n给定有序数组：[-10,-3,0,5,9]"),a("br"),t._v("\n0"),a("br"),t._v("\n/  <br/>\n-3   9"),a("br"),t._v("\n/     <br/>\n-10    5"),a("br")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("var soortedArrayToBST "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" function"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nums.length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" null"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" creatTree "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left, right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   \tif"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" null"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" mid "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Math.floor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("((")]),t._v("left + right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" / "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("let")]),t._v(" root "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new TreeNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       root.left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" createTree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left, mid -1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       root.right "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" createTree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mid + "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(", right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("return")]),t._v(" creatTree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(", nums.length - "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"不同的二叉搜索树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同的二叉搜索树"}},[t._v("#")]),t._v(" 不同的二叉搜索树")]),t._v(" "),a("p",[t._v("给定一个整数n,求以1...n为节点组成的二叉搜索树有多少种")]),t._v(" "),a("p",[t._v("** 示例 **")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("输入：3\n输出：5\n解释：\n给定n = 3,一共有五种不同的结构的二叉搜索树\n1      3   3     2    1\n \\    /   /     / \\    \\\n  3  2   1     1   3    2\n /  /     \\              \\\n2  1       2              3\n")])])]),a("p",[t._v("** 代码 **")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//动态规划\nvar numTrees = function(n) {\n\tconst dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for(let i = 2; i <= n; ++i) {\n    \tfor (j = 1; j <= i; ++i) {\n        \tdp[i] += dp[j - 1] * dp[i -j];\n        }\n    }\n    return dp[n];\n}\n")])])]),a("h2",{attrs:{id:"二叉树的最大深度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最大深度"}},[t._v("#")]),t._v(" 二叉树的最大深度")]),t._v(" "),a("p",[t._v("给定一个二叉树，找出其最大深度。")]),t._v(" "),a("p",[t._v("二叉树的深度为根节点到最远子节点的最长路径上的节点数。")]),t._v(" "),a("p",[t._v("说明：叶子节点是指没有节点的节点")]),t._v(" "),a("p",[t._v("实例：给定二叉树[3,9,20,null, null, 15,7]")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("     3\n   /  \\\n  9    20\n  \t   / \\\n      15  7\n")])])]),a("p",[t._v("题解")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.递归\n树的深度和它的左右子树的深度有关\n一个树的最大深度=根节点的高度+左右子树的最大深度中较大的那个\nconst maxDepth = (root) => {\n\tif(root === null) return 0;\n    const leftMaxDepth = maxDepth(root.left);\n    const rightMaxDepth = maxDepth(root.right);\n    return 1 + Math.max(leftMaxDepth, rightMaxDepth);\n}\n\n2.BFS\n\nconst maxDepth = (root) => {\n\tif(root == null) return 0;\n    const queue = [root];\n    const depth = 1;\n    while(queue.length) {\n    \tconst levelNum = queue.length; //当前层的节点个数\n        for (let i = 0; i < levelNum; i++) {\n        \tconst cur = queue.shift();\n            if (cur.left) queue.push(cur.left);\n            if(cur.right) queue.push(cur.right);\n        }\n        if (queue.length) depth++;\n    }\n    return depth;\n}\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);