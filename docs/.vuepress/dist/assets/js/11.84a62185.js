(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{383:function(n,t,e){"use strict";e.r(t);var r=e(42),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"快排"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快排"}},[n._v("#")]),n._v(" 快排")]),n._v(" "),e("h3",{attrs:{id:"阮一峰老师的js快排实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阮一峰老师的js快排实现"}},[n._v("#")]),n._v(" 阮一峰老师的js快排实现")]),n._v(" "),e("ol",[e("li",[n._v("选择数组中间书作为基数，并从数组中取出此基数")]),n._v(" "),e("li",[n._v("准备两个数组容器，遍历数组，逐个与基数比对，较小的放左容器，较大的放右容器")]),n._v(" "),e("li",[n._v("递归处理两个容器的元素，并将处理后的数据与基数按大小合并成一个数组返回")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var quickSort = function(arr) {\n    if (arr.length <= 1) return arr;\n    var pivotIndex = Math.floor(arr.length / 2);\n    var pivot = arr.splice(pivotIndex, 1)[0];\n    var left = [];\n    var right = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot], quickSort(right));\n}\n")])])]),e("p",[e("strong",[n._v("总结")])]),n._v(" "),e("p",[n._v('思路非常清晰，选择基数作为参照，划分数组,分而治之，对于新手来理解快排的核心思想"参照-划分-递归"，很容易理解')]),n._v(" "),e("p",[n._v("既实现了排序，又符合快速排序的思想，为什么还会有人诟病呢，是因为：")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("取基数用的是splice()函数取，而不是算法中常用的取下标。基数只是一个参照对象，在比对的时候，只要能从数组中取到就好，所以只需要知道它的索引，调用函数删除基数只会更耗时。")])]),n._v(" "),e("li",[e("p",[n._v("根据基数来划分时,专门生成两个数组来存储，从而占用更多的存储空间(增加了空间复杂度)")])])]),n._v(" "),e("p",[n._v("严格来讲，还有更多改进之处")]),n._v(" "),e("h3",{attrs:{id:"文章中提出的快排js实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文章中提出的快排js实现"}},[n._v("#")]),n._v(" 文章中提出的快排js实现")]),n._v(" "),e("p",[n._v("思路：")]),n._v(" "),e("p",[n._v("1、通过下标取中间数为基数；")]),n._v(" "),e("p",[n._v("2、从起点往后寻找比基数大的，记录为下标 i；再从终点往前寻找比基数小的，记录为下标 j，当 i <= j时，原地交换数值；")]),n._v(" "),e("p",[n._v("3、重复步骤2，直到遍历所有元素，并记录遍历的最后一个下标 i，以此下标为分界线，分为左右两边，分别重复步骤1~3实现递归排序；")]),n._v(" "),e("p",[n._v("实现（为方便理解，在原文基础上有所合并）：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 快排改进——黄佳新\nvar devide_Xin = function (array, start, end) {\n    if(start >= end) return array;\n    var baseIndex = Math.floor((start + end) / 2), // 基数索引\n            i = start,\n            j = end;\n\n    while (i <= j) {\n        while (array[i] < array[baseIndex]) {\n            i++;\n        }\n        while (array[j] > array[baseIndex])  {\n            j--;\n        }\n\n        if(i <= j) {\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n            i++;\n            j--;\n        }\n    }\n    return i;\n}\n\nvar quickSort_Xin = function (array, start, end) {\n    if(array.length < 1) {\n        return array;\n    }\n    var index = devide_Xin(array, start, end);\n    if(start < index -1) {\n        quickSort_Xin(array, start, index - 1);\n    }\n    if(end > index) {\n        quickSort_Xin(array, index, end);\n    }\n\n    return array;\n}\n")])])]),e("p",[n._v("总结：")]),n._v(" "),e("p",[n._v("1、用下标取基数，只有一个赋值操作，跟快；")]),n._v(" "),e("p",[n._v("2、原地交换，不需要新建多余的数组容器存储被划分的数据，节省存储；")]),n._v(" "),e("p",[n._v("比较：")]),n._v(" "),e("p",[n._v("相较而言，理论分析，实现二确实是更快速更省空间，那么事实呢？\n"),e("img",{attrs:{src:"/images/1115094-20180614151451933-1234664957.png",alt:"耗时比较"}})]),n._v(" "),e("p",[n._v("以上是实现一与实现二在chrome上测试耗时的统计结果，测试方案为：各自随机生成100万个数（乱序）,分别完成排序，统计耗时。")]),n._v(" "),e("p",[n._v("结论：")]),n._v(" "),e("p",[n._v("事实上，乱序排序，实现二更快。")]),n._v(" "),e("h3",{attrs:{id:"三、网上其他的快排js实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、网上其他的快排js实现"}},[n._v("#")]),n._v(" 三、网上其他的快排js实现")]),n._v(" "),e("p",[n._v("思路：")]),n._v(" "),e("p",[n._v("1、通过下表取排序区间的第0个数为基数")]),n._v(" "),e("p",[n._v("2、排序区间基数以后，从右往左，寻找比基数小的，从左往右，寻找比基数大的，原地交换；")]),n._v(" "),e("p",[n._v("3、重复步骤2直到 i >= j；")]),n._v(" "),e("p",[n._v("4、将基数与下标为 i 的元素原地交换，从而实现划分；")]),n._v(" "),e("p",[n._v("5、递归排序基数左边的数，递归排序基数右边的数，返回数组。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var quickSort_New = function(ary, left, right) {\n    if(left >= right) {\n        return ary;\n    }\n\n    var i = left,\n            j = right;\n            base = ary[left];\n\n    while (i < j) {\n        // 从右边起，寻找比基数小的数\n        while (i<j && ary[j] >= base) {\n            j--;\n        }\n\n        // 从左边起，寻找比基数大的数\n        while (i<j && ary[i] <= base) {\n            i++\n        } \n\n        if (i<j) {\n            var temp = ary[i];\n            ary[i] = ary[j];\n            ary[j] = temp;\n        }\n    }\n\n    ary[left] = ary[i];\n    ary[i] = base;\n\n    quickSort_New(ary, left, i-1);\n    quickSort_New(ary, i+1, right);\n\n    return ary;\n}\n")])])]),e("p",[n._v("总结：")]),n._v(" "),e("p",[n._v("除选基数不同以外，其他与实现二类似。")]),n._v(" "),e("p",[n._v("另外：")]),n._v(" "),e("p",[n._v("比较一下实现二与实现三的速度，结果如下：\n"),e("img",{attrs:{src:"/images/1115094-20180614154538001-997011957.png",alt:"二三比较"}}),n._v("\n多次测试结果均为：实现二耗时略小于实现三，偶尔出现大于的情况，但相差不大。")]),n._v(" "),e("h2",{attrs:{id:"扑克牌问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扑克牌问题"}},[n._v("#")]),n._v(" 扑克牌问题")]),n._v(" "),e("p",[n._v("有一堆扑克牌，将牌第一张放到桌子上，在将接下来牌的第一张放到牌底，如此往复；最后桌子上的牌顺序为:(牌底)1，2，3，4，5，6，6，7，8，9，10，11，12，13(牌顶)；"),e("br"),n._v("\n问：原来牌的顺序，用函数实现")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let arr = [1,2,3,4,5,6,7,8,9,10,11,12,13];\nlet _arr = [];\nfunction sortPoke() {\n    while(arr.length > 0) {\n        //选择抽取哪张牌\n        if(arr.length % 2 === 1) {\n            _arr.push(arr.pop());\n        } else {\n            _arr.push(arr.shift());\n        }\n    }\n    return _arr;\n}\nconsole.log(sortPoke())\n//[13, 1, 12, 2, 11, 3, 10, 4, 9, 5, 8, 6, 7]\n")])])]),e("h2",{attrs:{id:"javascript-深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-深拷贝"}},[n._v("#")]),n._v(" JavaScript 深拷贝")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//\nfunction copyObj(obj) {\n    var newobj = {};\n    for(const key in obj) {\n        if(typeof obj[key] === 'object') {\n            newobj[key] = copyObj(obj[key])\n        } else {\n            newobj[key] = obj[key]\n        }\n    }\n    return newobj;\n}\n/** MessageChannel接口允许创建一个新的消息通道，并通过它的两个MessagePort属性发送数据。MessageChannel接口实例化以后，会有两个属性port1和port2.**/\nfunction copyObj(obj) {\n    return new Promise(resolve => {\n        const { port1, port2 } = new MessageChannel();\n        port1.postMessage(obj);\n        port2.onmessage = ev => resolve(ev.data);\n    })\n}\nvar obj1 = {a:1}\nvar clone1 = await structuralClone(obj1)\n")])])]),e("h2",{attrs:{id:"盛水最多的容器-双指针法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#盛水最多的容器-双指针法"}},[n._v("#")]),n._v(" 盛水最多的容器---双指针法")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var maxArea = function(height) {\n    var left = 0;\n    var right = height - 1;\n    var max = 0;\n    while(left < right) {\n        var now = (right - left) * Math.min(height[right], height[left]);\n       max = now > max ? now : max;\n       if (height[left] > height[right]) {\n        right --;\n        } else {\n        left++;\n       }\n    }\n    return max;\n}\n")])])]),e("h2",{attrs:{id:"大数相加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大数相加"}},[n._v("#")]),n._v(" 大数相加")]),n._v(" "),e("p",[n._v("思路遍历两个字符串从个位数算起开始相加，定义temp接受两个数之和，除以10取余拼接上结果，最后判断temp是否大于0，如果大于9则进位temp=1\n"),e("code",[n._v("var addstring = function(num1, num2) { var len1 = num1.length, len2 = num2.length; temp = 0; res = ''; while(len1 || len2) { if(len1) { temp += +num1[--len1]; } if(len2) { temp += +num2[--len2]; } res = temp % 10 +res; if(temp > 9) { temp =1; } else { temp = 0; } if (temp) { res = 1 +res; } } return res; }")])]),n._v(" "),e("h2",{attrs:{id:"sqrt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sqrt"}},[n._v("#")]),n._v(" sqrt")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var mySqrt = function(x) {\n     if (x < 2) return x\n     let left = 1, mid, right = Math.floor(x / 2);\n     while (left <= right) {\n        mid = Math.floor(left + (right - left) / 2)\n        if (mid * mid === x) return mid\n        if (mid * mid < x) {\n            left = mid + 1\n        }else {\n            right = mid - 1\n        }\n     }\n     return right\n};\n")])])]),e("h2",{attrs:{id:"恢复空格"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#恢复空格"}},[n._v("#")]),n._v(" 恢复空格")]),n._v(" "),e("p",[n._v("哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子\"I reset the computer.It still didn't boot!\"已经变成'iresetthecomputeritstilldidntboot'。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary,不过有些词没在词典里。假设文章用sentence表示，设计一个是算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。")]),n._v(" "),e("p",[n._v("注意：本题对原题稍作改动，只需返回未识别的字符数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//示例\n输入：dictionary = ['looked', 'just', 'like', 'her', 'brother'];\nsentence = 'jesslookedjustliketimherbrother';\n输出 7\n解释：断句后'jess looked just like tim her brother',共7个未识别字符。\n\nvar respace = function(dictionary, sentence) {\n     if(sentence.length == 0) return 0;\n    let dp = new Array(sentence.length).fill(0);\n    for(let i = 1;i<=sentence.length;i++){\n        dp[i] = dp[i-1]+1;\n        // 上面表示，如果没有匹配那么dp[i]相比于dp[i-1]直接多1\n        // 接着讨论如果新加一个字符，组成了一个词的情况\n        for(let j=0;j<dictionary.length;j++){\n            let word = dictionary[j].length;\n            if(dictionary[j] == sentence.substring(i-word,i) && word<=i){\n                dp[i] = Math.min(dp[i],dp[i-word]);\n            }\n        }\n    }\n    return dp[sentence.length]\n};\n")])])]),e("h2",{attrs:{id:"两个数组的交集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两个数组的交集"}},[n._v("#")]),n._v(" 两个数组的交集")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n给定两个数组，编写一个函数来计算它们的交集。\n示例1：\n输入：nums1 = [1,2,2,1], num2 = [2,2];\n输出： [2,2]\n说明：\n   输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致\n   我们可以不用考虑输出结果的顺序\n**/\nvar intersect = function(nums1, nums2) {\n    let tmp = [], arr = [];\n    if(nums1.length > nums2.length) {\n        tmp = nums1;\n        nums1 = nums2;\n        nums2 = tmp;\n    }\n    for (let key of nums1) {\n        temp = nums2.indexOf(key);\n        if(temp > -1) {\n            arr.push(key);\n            nums2.splice(temp, 1);\n        }\n    } \n    return arr;\n}\n\n\n// 交集并集差集\n  var set1 = new Set([1,2,3]);\n  var set2 = new Set([2,3,4]);\n\n  并集\n  let union = new Set([...set1, ...set2]);\n\n  交集\n  let intersect = new Set([...set1].filter( x => set2.has(x)));\n\n  差集\n  let difference = new Set([...set1].filter(x => !set2.has(x)));\n\n\n")])])]),e("h2",{attrs:{id:"分割数组最大值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分割数组最大值"}},[n._v("#")]),n._v(" 分割数组最大值")]),n._v(" "),e("p",[n._v("给定一个非负整数数组和一个整数m,你需要将这个数组分成m个非空的连续子数组。设计一个算法使得这个m个子数组各自和的最大值最小。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//贪心算法\nvar splitArray = function(nums, m) {\n    let left = 0; right = 0;\n    let len = nums.length;\n    for(let i = 0; i < len; i++) {\n        right += nums[i];\n        if(left < nums[i]) {\n            left = num[i];\n        }\n    }\n    function check(mid, m) {\n        let sum = 0;\n        let cnt = 1;\n        for (let i = 0; i < len; i++) {\n            if (sum + nums[i] > mid) {\n                cnt++;\n                sum = nums[i];\n            } else {\n                sum += nums[i];\n            }\n        }\n        return cnt <= m;\n    }\n    while(left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (check(mid, m)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n")])])]),e("h3",{attrs:{id:"链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[n._v("#")]),n._v(" 链表")]),n._v(" "),e("ol",[e("li",[n._v("判断单链表是否带环")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//第一种方法\nfunction judge(list) {\n\tvar set = new Set();\n    while(list) {\n    \tif (set.has(list)) {\n        \tconsole.log('存在环')；\n            console.log(list);\n            return true;\n        }\n        set.add(list);\n        list = list.next();\n    }\n    return set;\n}\n//快慢指针，设定快指针fast,慢指针slow,每次循环快指针fast移动两个位置，慢指针移动一个位置\nfunction judge(list) {\n\t//创建快慢指针\n    var fast = list.next.next,\n    \tslow = list.next;\n    while(list) {\n    \tif (fast === slow) {\n        \tconsole.log('存在环')；\n            console.log('fast:', fast);\n            console.log('slow:', slow);\n            return true;\n        }\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n}\n")])])]),e("h2",{attrs:{id:"逻辑思维"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#逻辑思维"}},[n._v("#")]),n._v(" 逻辑思维")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？\n三个都喜欢的人数最多时，就尽量重复排列\n60 70(10人喜欢一个)\n70 80(现共有80人， 60人喜欢三个 ，10人喜欢两个， 10人喜欢一个)")]),n._v(" "),e("p",[n._v("所以10%- 60%")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);